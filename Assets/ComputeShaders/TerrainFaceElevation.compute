/*#pragma kernel VerticesWithElevationCompute

RWStructuredBuffer<float3> Vertices;

uint numVertices;
float4 quadVerticesPreset[100];
float4x4 transformMat;
Texture2D<float4> InputTexture;
float RadiusU; 
float MaxAltitude;
float MaxRatio;

float LinearInterpolation(float x1, float y1, float x3, float y3, float xValToGuessY)
{
    return (y3-y1)/(x3-x1) * (xValToGuessY-x1) + y1;
}

float Clamp(float value, float min, float max)
{
    if(value <= min) {
        return min;
    }
    else if(value >= max) {
        return max;
    }
    return value;
}

[numthreads(512,1,1)]
void VerticesWithElevationCompute (uint id : SV_DispatchThreadID)
{
	if (id >= numVertices) { return; }

    float pi = 3.14159265359;
    float pi_x_2 = 6.28318530718;
    uint width, height, pixelWidthOffset;
    InputTexture.GetDimensions(width, height);
    pixelWidthOffset = width - (0.5 + atan2(1, 0) / pi_x_2) * width;

    float3 presetVertex = quadVerticesPreset[id].xyz;
	float3 pointOnUnitSphere = normalize(mul(transformMat, presetVertex));

    float pixel_w = (0.5 + atan2(pointOnUnitSphere.x, pointOnUnitSphere.z) / pi_x_2) * textureWidth;
    float pixel_h = (0.5 - asin(pointOnUnitSphere.y) / pi) * textureHeight;
    if(pixel_w - pixelWidthOffset < 0) {
        pixel_w = textureWidth + (pixel_w - pixelWidthOffset);
    }
    else {
        pixel_w = pixel_w - pixelWidthOffset;
    }

    if(pixel_w > textureWidth) {
        pixel_w = pixel_w - textureWidth;
    }
	
    float grayVal = InputTexture[float2(pixel_w, pixel_h)].g;
    float elevation = LinearInterpolation(0, 0, 1, MaxAltitude, grayVal) / RadiusU);
    elevation = 1 + Clamp(elevation, 0, MaxRatio);

    Vertices[id] = pointOnUnitSphere * elevation * RadiusU;
}*/